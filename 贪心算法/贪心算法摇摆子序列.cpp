//***********************************************************
//  贪心算法解决摇摆子序列
// **********************************************************

// leetcode 376 https://leetcode-cn.com/problems/wiggle-subsequence/
/********************************************************************
*如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如，?[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)?是正负交替出现的。相反, [1,4,7,2,5]?和?[1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:

输入: [1,7,4,9,2,5]
输出: 6
解释: 整个序列均为摆动序列。
示例 2:

输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
示例 3:

输入: [1,2,3,4,5,6,7,8,9]
输出: 2

来源：力扣（LeetCode）

*
*********************************************************************/

// 分析: 摇摆序列的数值在大小上有波浪的那种效果,  例如: 1, 3 ,2, 4
// [1, 17, 5, 10, 13, 15, 10, 5, 16, 8] //
// 递增序列: [ 5, 13, 15] 如果序列有上升或者下降的状态, 保留上升或者下降状态的首尾元素, 既可以组成摇摆序列
//
#include<iostream>
#include<algorithm>

using namespace std;

class Solution {
	public:
		int wiggleMaxLength(vector<int>& nums) {
			// 如果vector 中只有一个元素或者没有元素, 则形成的摇摆序列是 vector 的元素的个数
			if ( nums .size () < 2) {
				return   nums.size();
			}

			static const int BEGIN = 0 ; // 开始遍历
			static const int UP =1; // 当前是上升的状态
			static const int DOWN = 2; // 当前是下降的状态

			int STATE = BEGIN; // 初始的状态为开始的状态
			int max_length = 1;
			for ( int i = 1; i< nums.size() ; i++ ) {

				switch(STATE) {
					case BEGIN:
						// 如果上一个元素比当前的元素大, 表示遇到了一个转折的点, 这里相当于遇到了一个首元素
						if (nums[i -1 ] > nums[i] ) {
							max_length ++; // 长度加一
							STATE = DOWN; // 改变当前的状态
						} else if (nums [i -1] < nums[i]) {
							// 如果当前的元素大于之前的元素, 表示遇到了一个上升的转折点, 这个元素为首元素
							max_length ++;
							STATE = UP; // 当前的状态为上升序列
						}
						break;

					case UP:
						// 如果当前的状态是上升的状态
						// 当前的元素比前一个元素要小, 表示前一个元素是 上升序列的最后一个元素, 这里需要改变当前的状态, 可用的长度加一
						if (nums[i-1] > nums[i]) {
							max_length ++;
							STATE = DOWN;
						}
						break;

					case DOWN:
						// 如果当前的元素数是 下降趋势, 并且当前的元素比上一个元素还要大, 表示上一个元素是下降趋势的最小值, 这里需要改变过当前的状态
						if (nums[i-1] < nums[i]) {
							max_length ++;
							STATE = UP;
						}
						break;
				}

			}
			return max_length;

		}
};

int main(void) {
	cout<<"hello world"<<endl;
	vector<int>nums = {1, 17, 5, 10, 13, 15, 10, 5, 16, 8};
	cout<<Solution().wiggleMaxLength(nums) <<endl; // 7 
	return 0;
}


